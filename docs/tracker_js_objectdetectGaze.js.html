<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>tracker/js_objectdetectGaze.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BlinkDetector.html">BlinkDetector</a></li><li><a href="ClmGaze.html">ClmGaze</a><ul class='methods'><li data-type='method'><a href="ClmGaze.html#getEyePatches">getEyePatches</a></li><li data-type='method'><a href="ClmGaze.html#getEyePatches">getEyePatches</a></li></ul></li><li><a href="DebugBox.html">DebugBox</a><ul class='methods'><li data-type='method'><a href="DebugBox.html#addButton">addButton</a></li><li data-type='method'><a href="DebugBox.html#addButton">addButton</a></li><li data-type='method'><a href="DebugBox.html#inc">inc</a></li><li data-type='method'><a href="DebugBox.html#inc">inc</a></li><li data-type='method'><a href="DebugBox.html#set">set</a></li><li data-type='method'><a href="DebugBox.html#set">set</a></li><li data-type='method'><a href="DebugBox.html#show">show</a></li><li data-type='method'><a href="DebugBox.html#show">show</a></li></ul></li><li><a href="LinearReg.html">LinearReg</a><ul class='methods'><li data-type='method'><a href="LinearReg.html#addData">addData</a></li><li data-type='method'><a href="LinearReg.html#addData">addData</a></li><li data-type='method'><a href="LinearReg.html#getData">getData</a></li><li data-type='method'><a href="LinearReg.html#getData">getData</a></li><li data-type='method'><a href="LinearReg.html#predict">predict</a></li><li data-type='method'><a href="LinearReg.html#predict">predict</a></li><li data-type='method'><a href="LinearReg.html#setData">setData</a></li><li data-type='method'><a href="LinearReg.html#setData">setData</a></li></ul></li><li><a href="module-TrackingjsGaze.html">TrackingjsGaze</a><ul class='methods'><li data-type='method'><a href="module-TrackingjsGaze.html#detectEyes">detectEyes</a></li><li data-type='method'><a href="module-TrackingjsGaze.html#detectEyes">detectEyes</a></li><li data-type='method'><a href="module-TrackingjsGaze.html#detectFace">detectFace</a></li><li data-type='method'><a href="module-TrackingjsGaze.html#detectFace">detectFace</a></li><li data-type='method'><a href="module-TrackingjsGaze.html#findLargestRectangle">findLargestRectangle</a></li><li data-type='method'><a href="module-TrackingjsGaze.html#findLargestRectangle">findLargestRectangle</a></li><li data-type='method'><a href="module-TrackingjsGaze.html#getEyePatches">getEyePatches</a></li><li data-type='method'><a href="module-TrackingjsGaze.html#getEyePatches">getEyePatches</a></li></ul></li><li><a href="RidgeReg.html">RidgeReg</a><ul class='methods'><li data-type='method'><a href="RidgeReg.html#addData">addData</a></li><li data-type='method'><a href="RidgeReg.html#addData">addData</a></li><li data-type='method'><a href="RidgeReg.html#getData">getData</a></li><li data-type='method'><a href="RidgeReg.html#getData">getData</a></li><li data-type='method'><a href="RidgeReg.html#predict">predict</a></li><li data-type='method'><a href="RidgeReg.html#predict">predict</a></li><li data-type='method'><a href="RidgeReg.html#setData">setData</a></li><li data-type='method'><a href="RidgeReg.html#setData">setData</a></li></ul></li><li><a href="RidgeWightedReg.html">RidgeWightedReg</a><ul class='methods'><li data-type='method'><a href="RidgeWightedReg.html#addData">addData</a></li><li data-type='method'><a href="RidgeWightedReg.html#addData">addData</a></li><li data-type='method'><a href="RidgeWightedReg.html#getData">getData</a></li><li data-type='method'><a href="RidgeWightedReg.html#getData">getData</a></li><li data-type='method'><a href="RidgeWightedReg.html#predict">predict</a></li><li data-type='method'><a href="RidgeWightedReg.html#predict">predict</a></li><li data-type='method'><a href="RidgeWightedReg.html#setData">setData</a></li><li data-type='method'><a href="RidgeWightedReg.html#setData">setData</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-Js_objectdetectGaze.html">Js_objectdetectGaze</a><ul class='methods'><li data-type='method'><a href="module-Js_objectdetectGaze.html#detectEyes">detectEyes</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#detectEyes">detectEyes</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#detectFace">detectFace</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#detectFace">detectFace</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#findLargestRectangle">findLargestRectangle</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#findLargestRectangle">findLargestRectangle</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#getEyePatches">getEyePatches</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#getEyePatches">getEyePatches</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#mergeRectangles">mergeRectangles</a></li><li data-type='method'><a href="module-Js_objectdetectGaze.html#mergeRectangles">mergeRectangles</a></li></ul></li><li><a href="module-RidgeThreadedReg.html">RidgeThreadedReg</a><ul class='methods'><li data-type='method'><a href="module-RidgeThreadedReg.html#addData">addData</a></li><li data-type='method'><a href="module-RidgeThreadedReg.html#addData">addData</a></li><li data-type='method'><a href="module-RidgeThreadedReg.html#getData">getData</a></li><li data-type='method'><a href="module-RidgeThreadedReg.html#getData">getData</a></li><li data-type='method'><a href="module-RidgeThreadedReg.html#predict">predict</a></li><li data-type='method'><a href="module-RidgeThreadedReg.html#predict">predict</a></li><li data-type='method'><a href="module-RidgeThreadedReg.html#setData">setData</a></li><li data-type='method'><a href="module-RidgeThreadedReg.html#setData">setData</a></li></ul></li><li><a href="module-webgazer.html">webgazer</a><ul class='methods'><li data-type='method'><a href="module-webgazer.html#.getEventTypes">getEventTypes</a></li><li data-type='method'><a href="module-webgazer.html#.getEventTypes">getEventTypes</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#bound">bound</a></li><li><a href="global.html#DataWindow">DataWindow</a></li><li><a href="global.html#equalizeHistogram">equalizeHistogram</a></li><li><a href="global.html#Eye">Eye</a></li><li><a href="global.html#getCurrentFixationIndex">getCurrentFixationIndex</a></li><li><a href="global.html#getEyeFeats">getEyeFeats</a></li><li><a href="global.html#getMatrix">getMatrix</a></li><li><a href="global.html#getPupils">getPupils</a></li><li><a href="global.html#getSinglePupil">getSinglePupil</a></li><li><a href="global.html#getSubMatrix">getSubMatrix</a></li><li><a href="global.html#getSumTable">getSumTable</a></li><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#grayscale">grayscale</a></li><li><a href="global.html#KalmanFilter">KalmanFilter</a></li><li><a href="global.html#LUDecomposition">LUDecomposition</a></li><li><a href="global.html#mult">mult</a></li><li><a href="global.html#QRDecomposition">QRDecomposition</a></li><li><a href="global.html#resizeEye">resizeEye</a></li><li><a href="global.html#retrain">retrain</a></li><li><a href="global.html#ridge">ridge</a></li><li><a href="global.html#transpose">transpose</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">tracker/js_objectdetectGaze.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Constructor for Js_objectdetectGaze which captures face and eye positions using the js_objectdetect library
 * @alias module:Js_objectdetectGaze
 * @exports Js_objectdetectGaze
 */
var Js_objectdetectGaze = function () {};

/**
 * The Js_objectdetectGaze object name
 * @type {string}
 */
Js_objectdetectGaze.prototype.name = 'js_objectdetect';

/**
 * Isolates the two patches that correspond to the user's eyes
 * @param  {HTMLCanvasElement} imageCanvas - canvas corresponding to the webcam stream
 * @param  {Number} width - of imageCanvas
 * @param  {Number} height - of imageCanvas
 * @return {Object} the two eye-patches, first left, then right eye
 */
Js_objectdetectGaze.prototype.getEyePatches = function (imageCanvas, width, height) {

    if (imageCanvas.width == 0) {
        return null;
    }

    //current ImageData that correspond to the working image.
    //It can be the whole canvas if the face detection failed or only the upper half of the face to avoid unnecessary computations
    var workingImage = imageCanvas.getContext('2d').getImageData(0, 0, width, height);

    var face = this.detectFace(imageCanvas, width, height);

    //offsets of the working image from the top left corner of the video canvas
    var offsetX = 0;
    var offsetY = 0;

    //if face has been detected
    if (face.length > 0 &amp;&amp; !isNaN(face[0]) &amp;&amp; !isNaN(face[1]) &amp;&amp; !isNaN(face[2]) &amp;&amp; !isNaN(face[3])) {
        //working image is restricted on upper half of detected face
        workingImage = imageCanvas.getContext('2d').getImageData(Math.floor(face[0]), Math.floor(face[1]), Math.floor(face[2]), Math.floor(face[3] / 2));
        width        = Math.floor(face[2]);
        height       = Math.floor(face[3] / 2);
        //offset from detected face
        offsetX      = Math.floor(face[0]);
        offsetY      = Math.floor(face[1]);
    }

    var eyes = this.detectEyes(workingImage, width, height);
    if (eyes == null) {
        return null;
    }

    var eyeObjs       = {};
    var leftImageData = imageCanvas.getContext('2d').getImageData(Math.floor(eyes[0][0]) + offsetX, Math.floor(eyes[0][1]) + offsetY, Math.floor(eyes[0][2]), Math.floor(eyes[0][3]));
    eyeObjs.left      = {
        patch:  leftImageData,
        imagex: eyes[0][0] + offsetX,
        imagey: eyes[0][1] + offsetY,
        width:  eyes[0][2],
        height: eyes[0][3]
    };

    var rightImageData = imageCanvas.getContext('2d').getImageData(Math.floor(eyes[1][0]) + offsetX, Math.floor(eyes[1][1]) + offsetY, Math.floor(eyes[1][2]), Math.floor(eyes[1][3]));
    eyeObjs.right      = {
        patch:  rightImageData,
        imagex: eyes[1][0] + offsetX,
        imagey: eyes[1][1] + offsetY,
        width:  eyes[1][2],
        height: eyes[1][3]
    };

    if (leftImageData.width == 0 || rightImageData.width == 0) {
        console.log('an eye patch had zero width');
        return null;
    }

    return eyeObjs;
};

/**
 * Performs eye detection on the passed workingImage
 * @param {ImageData} workingImage - either the whole canvas or the upper half of the head
 * @param {Number} workingImageWidth - width of working image
 * @param {Number} workingImageHeight - height of working image
 * @return {Array} eyes - array of rectangle information.
 */
Js_objectdetectGaze.prototype.detectEyes = function (workingImage, workingImageWidth, workingImageHeight) {

    var tempCanvas    = document.createElement('canvas');
    tempCanvas.width  = workingImageWidth;
    tempCanvas.height = workingImageHeight;
    tempCanvas.getContext('2d').putImageData(workingImage, 0, 0);

    //Following js_objectdetect conventions resize workingImage
    var eyes             = [];
    var intermediateEyes = [];
    var width            = ~~(60 * workingImageWidth / workingImageHeight);
    var height           = 60;
    var detector         = new objectdetect.detector(width, height, 1.1, objectdetect.eye);
    intermediateEyes     = detector.detect(tempCanvas, 0);
    eyes                 = this.mergeRectangles(intermediateEyes);
    if (typeof eyes !== 'undefined') {
        for (var i = 0; i &lt; eyes.length; i++) {
            // Rescale coordinates from detector to video coordinate space:
            eyes[i][0] *= workingImageWidth / detector.canvas.width;
            eyes[i][1] *= workingImageHeight / detector.canvas.height;
            eyes[i][2] *= workingImageWidth / detector.canvas.width;
            eyes[i][3] *= workingImageHeight / detector.canvas.height;
        }

        eyes.sort(function (a, b) {
            return a[0] - b[0]
        });
        return eyes;
    }
    else {
        console.log('js_objectdetect could not detect two eyes in the video');
        return null;
    }
};

/**
 * Performs face detection on the passed canvas
 * @param {HTMLCanvasElement} imageCanvas - whole video canvas
 * @param {Number} workingImageWidth - width of imageCanvas
 * @param {Number} workingImageHeight - height of imageCanvas
 * @return {Array.&lt;Array.&lt;Number>>} face - array of rectangle information
 */
Js_objectdetectGaze.prototype.detectFace = function (imageCanvas, workingImageWidth, workingImageHeight) {
    var intermediateFaces = [];
    var face              = [];
    var width             = ~~(60 * workingImageWidth / workingImageHeight);
    var height            = 60;
    var detector          = new objectdetect.detector(width, height, 1.1, objectdetect.frontalface_alt);
    intermediateFaces     = detector.detect(imageCanvas, 1);
    face                  = this.findLargestRectangle(intermediateFaces);
    // Rescale coordinates from detector to video coordinate space:
    face[0] *= workingImageWidth / detector.canvas.width;
    face[1] *= workingImageHeight / detector.canvas.height;
    face[2] *= workingImageWidth / detector.canvas.width;
    face[3] *= workingImageHeight / detector.canvas.height;
    return face;
};

/**
 * Goes through an array of rectangles and returns the one with the largest area
 * @param {Array.&lt;Array.&lt;Number>>} rectangles - array of arrays of format [xCoordinate, yCoordinate, width, height]
 * @return {Array} largestRectangle = [xCoordinate, yCoordinate, width, height]
 */
Js_objectdetectGaze.prototype.findLargestRectangle = function (rectangles) {
    var largestArea      = 0;
    var area             = 0;
    var largestRectangle = [];
    for (var i = 0; i &lt; rectangles.length; ++i) {
        area = rectangles[i][2] * rectangles[i][3];
        if (area > largestArea) {
            largestArea      = area;
            largestRectangle = rectangles[i];
        }
    }
    return largestRectangle;
};

/**
 * Merges detected rectangles in clusters
 * Taken from trackingjs and modified slightly to reflect that rectangles are arrays and not objects
 * @param  {Array.&lt;Array.&lt;Number>>} rects - rectangles to me clustered
 * @return {Array.&lt;Array.&lt;Number>>} result merged rectangles
 */
Js_objectdetectGaze.prototype.mergeRectangles = function (rects) {
    var disjointSet = new tracking.DisjointSet(rects.length);

    for (var i = 0; i &lt; rects.length; i++) {
        var r1 = rects[i];
        for (var j = 0; j &lt; rects.length; j++) {
            var r2 = rects[j];
            if (tracking.Math.intersectRect(r1[0], r1[1], r1[0] + r1[2], r1[1] + r1[3], r2[0], r2[1], r2[0] + r2[2], r2[1] + r2[3])) {
                var x1      = Math.max(r1[0], r2[0]);
                var y1      = Math.max(r1[1], r2[1]);
                var x2      = Math.min(r1[0] + r1[2], r2[0] + r2[2]);
                var y2      = Math.min(r1[1] + r1[3], r2[1] + r2[3]);
                var overlap = (x1 - x2) * (y1 - y2);
                var area1   = (r1[2] * r1[3]);
                var area2   = (r2[2] * r2[3]);

                if ((overlap / (area1 * (area1 / area2)) >= 0.5) &amp;&amp;
                    (overlap / (area2 * (area1 / area2)) >= 0.5)) {
                    disjointSet.union(i, j);
                }
            }
        }
    }

    var map = {};
    for (var k = 0; k &lt; disjointSet.length; k++) {
        var rep = disjointSet.find(k);
        if (!map[rep]) {
            map[rep] = {
                total:  1,
                width:  rects[k][2],
                height: rects[k][3],
                x:      rects[k][0],
                y:      rects[k][1]
            };
            continue;
        }
        map[rep].total++;
        map[rep].width += rects[k][2];
        map[rep].height += rects[k][3];
        map[rep].x += rects[k][0];
        map[rep].y += rects[k][1];
    }

    var result = [];
    Object.keys(map).forEach(function (key) {
        var rect = map[key];
        result.push([((rect.x / rect.total + 0.5) | 0), ((rect.y / rect.total + 0.5) | 0), ((rect.width / rect.total + 0.5) | 0), ((rect.height / rect.total + 0.5) | 0)]);
    });
    return result;
};

export {Js_objectdetectGaze};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Nov 22 2016 16:59:29 GMT+0100 (Paris, Madrid) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
